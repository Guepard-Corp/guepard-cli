name: Build, Push, and Test CLI Tool

on:
  workflow_dispatch:

jobs:
  build-and-push:
    name: Build and Push Image
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: 1. Checkout repository üìÇ
        uses: actions/checkout@v4

      - name: 2. Create Dockerfile üìù
        run: |
          cat <<EOF > Dockerfile.generated
          FROM ubuntu:24.04
          
          ENV DEBIAN_FRONTEND=noninteractive
          RUN apt-get update && apt-get install -y build-essential procps curl file git
          
          RUN useradd -ms /bin/bash linuxbrew
          USER linuxbrew
          WORKDIR /home/linuxbrew
          # This is the correct way to execute the installation
          RUN /bin/bash -c "\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" && \
              eval "\$(/home/linuxbrew/.linuxbrew/bin/brew shellenv)" && \
              brew tap guepard-corp/guepard && \
              brew install guepard
          USER root
          ENTRYPOINT ["/home/linuxbrew/.linuxbrew/bin/guepard"]
          EOF
      - name: 3. Normalize repository name
        id: repo_name
        run: echo "repo_lc=$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')" >> "$GITHUB_OUTPUT"

      - name: 4. Set up Docker Buildx ‚öôÔ∏è
        uses: docker/setup-buildx-action@v3

      - name: 5. Log in to GitHub Container Registry üîê
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 6. Build and push Docker image with cache üèóÔ∏è‚û°Ô∏è
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.generated
          push: true
          tags: ghcr.io/${{ steps.repo_name.outputs.repo_lc }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

  test-stateless-commands:
    name: üìñ Test Command Outputs
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      packages: read
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Create a wrapper script for the CLI tool
        run: |
          mkdir -p $HOME/bin
          echo '#!/bin/bash' > $HOME/bin/guepard
          echo 'docker run --rm ghcr.io/${{ github.repository }}:latest "$@"' >> $HOME/bin/guepard
          chmod +x $HOME/bin/guepard
          echo "$HOME/bin" >> $GITHUB_PATH
      - name: Test - Main Help & Version
        continue-on-error: true
        run: |
          guepard --help
          guepard --version
      - name: Test - Subcommand Help Texts
        continue-on-error: true
        run: |
          guepard list --help
          guepard branch --help
          guepard commit --help
          guepard deploy --help
          guepard usage --help
          guepard log --help
          guepard login --help
          guepard checkout --help
          guepard compute --help
          guepard config --help
  test-login:
    name: üöÄ Test Login
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      packages: read
    steps:
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Create a wrapper script for the CLI tool
        run: |
          mkdir -p $HOME/bin
          echo '#!/bin/bash' > $HOME/bin/guepard
          echo 'docker run --rm --env GUEPARD_API_TOKEN ghcr.io/${{ github.repository }}:latest "$@"' >> $HOME/bin/guepard
          chmod +x $HOME/bin/guepard
          echo "$HOME/bin" >> $GITHUB_PATH
      - name: Check Login
        env:
          GUEPARD_API_TOKEN: ${{ secrets.GUEPARD_API_TOKEN }}
        run: |
          guepard login -c "$GUEPARD_API_TOKEN"
          
  e2e-test-scenario:
    name: üöÄ End-to-End Test Scenario
    runs-on: ubuntu-latest
    needs: build-and-push 
    permissions:
      packages: read

    steps:
      - name: Setup - Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create a wrapper script for the CLI tool
        run: |
          # Create a directory on the runner to persist the session data
          mkdir -p $HOME/.guepard-session
          mkdir -p $HOME/bin
          echo '#!/bin/bash' > $HOME/bin/guepard
          # ‚úÖ Use the correct path inside the container: /root/.guepard/
          # This maps the runner's directory to the container's config directory.
          echo 'docker run --rm --env GUEPARD_API_TOKEN -v $HOME/.guepard-session:/root/.guepard ghcr.io/${{ github.repository }}:latest "$@"' >> $HOME/bin/guepard
          chmod +x $HOME/bin/guepard
          echo "$HOME/bin" >> $GITHUB_PATH
      - name: Phase 1 - Authentication
        env:
          GUEPARD_API_TOKEN: ${{ secrets.GUEPARD_API_TOKEN }}
        run: |
          echo "Logging out for a clean session..."
          guepard logout || true
          echo "Logging in with API token..."
          guepard login -c "$GUEPARD_API_TOKEN"
          echo "Verifying login via usage command..."
          guepard usage
      - name: Phase 2 - Create Deployment and Capture ID
        id: deploy
        run: |
          UNIQUE_ID=$(date +%s)
          DEPLOYMENT_NAME="cli-e2e-test-${UNIQUE_ID}"
          echo "Attempting to create deployment: ${DEPLOYMENT_NAME}"
          # We run the command and capture its output
          output=$(guepard deploy -p PostgreSQL -v 16 -r us-west -i REPOSITORY -d aws -n "${DEPLOYMENT_NAME}" -w "S3cureP@ssword123!" -u "guepard" -f gp.g1.xsmall)
          echo "$output"
          # Parse the output to find the ID and save it as a step output
          deployment_id=$(echo "$output" | grep 'ID:' | awk '{print $2}')
          if [ -z "$deployment_id" ]; then
            echo "Failed to create or parse deployment ID!"
            exit 1
          fi
          echo "deployment_id=$deployment_id" >> "$GITHUB_OUTPUT"
      - name: Phase 2 - Wait for Deployment to Provision
        run: |
          echo "Waiting for deployment ${{ steps.deploy.outputs.deployment_id }} to be provisioned..."
          for i in {1..12}; do
            status_output=$(guepard deploy -x "${{ steps.deploy.outputs.deployment_id }}")
            if echo "$status_output" | grep -q "Status: CREATED"; then
              echo "Deployment is provisioned."
              exit 0
            fi
            echo "Attempt ${i}/12: Not ready. Waiting 15 seconds..."
            sleep 15
          done
          echo "Error: Deployment did not provision in time."
          exit 1
      - name: Phase 2 - Wait for Compute to be Healthy
        run: |
          echo "Waiting for compute instance of ${{ steps.deploy.outputs.deployment_id }} to be healthy..."
          for i in {1..12}; do
            compute_status=$(guepard compute status -x "${{ steps.deploy.outputs.deployment_id }}")
            if echo "$compute_status" | grep -q "Healthy"; then
              echo "Compute is healthy."
              exit 0
            fi
            echo "Attempt ${i}/12: Not healthy. Waiting 10 seconds..."
            sleep 10
          done
          echo "Error: Compute did not become healthy in time."
          exit 1
      - name: Phase 3 - Create Branch and Commit
        run: |
          DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment_id }}"
          TEST_BRANCH_NAME="ci-feature-branch-$(date +%s)"
          echo "--- 1. Finding the 'main' branch ID ---"
          BRANCH_LIST=$(guepard list branches -x "$DEPLOYMENT_ID")
          echo "$BRANCH_LIST"
          # Parse the output to get the ID of the 'main' branch (the first field in the table)
          MAIN_BRANCH_ID=$(echo "$BRANCH_LIST" | grep 'main' | awk '{print $2}')
          if [ -z "$MAIN_BRANCH_ID" ]; then
            echo "::error::Could not find the 'main' branch ID."
            exit 1
          fi
          echo "Found 'main' branch ID: $MAIN_BRANCH_ID"
          echo "--- 2. Creating a commit on the 'main' branch ---"
          guepard commit -m "Automated test commit on main" -x "$DEPLOYMENT_ID" -b "$MAIN_BRANCH_ID"
          echo "--- 3. Listing commits to find the new snapshot ID ---"
          COMMIT_LIST=$(guepard list commits -x "$DEPLOYMENT_ID")
          echo "$COMMIT_LIST"
          SNAPSHOT_ID=$(echo "$COMMIT_LIST" | grep '‚îÇ' | grep -oE '[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}' | head -n 1)
          if [ -z "$SNAPSHOT_ID" ]; then
            echo "::error::Failed to parse new SNAPSHOT_ID from the commit list."
            exit 1
          fi
          echo "Found new snapshot ID: $SNAPSHOT_ID"
          echo "--- 4. Creating new branch '${TEST_BRANCH_NAME}' from the snapshot ---"
          guepard branch -x "$DEPLOYMENT_ID" -s "$SNAPSHOT_ID" "$TEST_BRANCH_NAME"
          echo "--- 5. Verifying the new branch exists ---"
          guepard list branches -x "$DEPLOYMENT_ID"
      - name: Phase 4 - Compute Management
        run: |
          DEPLOYMENT_ID="${{ steps.deploy.outputs.deployment_id }}"
          echo "Stopping compute instance..."
          guepard compute stop -x "$DEPLOYMENT_ID"
          sleep 15
          guepard compute status -x "$DEPLOYMENT_ID"
          
          echo "Starting compute instance..."
          guepard compute start -x "$DEPLOYMENT_ID"
          sleep 15
          guepard compute status -x "$DEPLOYMENT_ID"
      - name: Phase 5 - Error Handling Tests (Expect Failures)
        run: |
          echo "Testing invalid UUID format..."
          # The '!' inverts the exit code. If the command fails (non-zero), '!' makes it 0 (success).
          if ! guepard deploy -x "invalid-uuid-format"; then
            echo "Command failed as expected. ‚úì"
          else
            echo "Error: Command succeeded but was expected to fail. ‚úó"
            exit 1
          fi
          echo "Testing non-existent deployment ID..."
          if ! guepard deploy -x "00000000-0000-0000-0000-000000000000"; then
            echo "Command failed as expected. ‚úì"
          else
            echo "Error: Command succeeded but was expected to fail. ‚úó"
            exit 1
          fi
      - name: Cleanup - Delete Resources and Logout
        # This step runs even if previous steps have failed
        if: always()
        run: |
          # Check if the deployment ID was successfully captured before trying to delete
          if [ -n "${{ steps.deploy.outputs.deployment_id }}" ]; then
            echo "Cleaning up deployment: ${{ steps.deploy.outputs.deployment_id }}"
            # Use '-y' for non-interactive confirmation
            guepard deploy -x "${{ steps.deploy.outputs.deployment_id }}" -y
          else
            echo "No deployment ID was captured, skipping deletion."
          fi
          echo "Logging out..."
          guepard logout